{"mappings":";;;;;;A;A,O,c,C,gB,c;I,O;A;A,c,C,U,G,K;A,e,I,G;;;AAcO,SAASY,2BACdC,OAAkD,EAClDC,iBAAyB,EACzBC,KAAmB,EACnBE,WAAgB;IAEhB,IAAMC,gBAAgB;QACpBC,MAAMC,+BAAOD,IAAI,CAACE,IAAI;QACtB,aAAaD,+BAAOD,IAAI,CAACG,IAAI;QAC7BC,KAAKH,+BAAOG,GAAG,CAACF,IAAI;QACpB,YAAYD,+BAAOG,GAAG,CAACD,IAAvB;IACF;IAEA,IAAME,OAAON,aAAa,CAACL,QAAQ;IAEnC,IAAI,CAACW,MACH,MAAM,IAAIC,MACR;IAIJ,YAAA;IACA,IAAMC,WAAW,AAAA,CAAA,GAAAC,mCAAAA,EAAYH;IAE7B,IAAMI,KAAK1B,gCAAoB4B,OAAO,CAAChB;IACvC,IAAMiB,MAAM7B,uCAA2B+B,eAAe,CAACL,IAAIF;IAE3D,SAASQ,oBAAoB9B,OAAO;QAClC,IAAM+B,MAAMlB,WAAW,CAACb,QAAQ;QAChC,IAAMgC,UAAUlC,2BAAeoC,OAAO,CAACH,KAAKT;QAC5C,OAAOU;IACT;IAEA,SAASG,QAAQC,aAAa,EAAEC,KAAK;QACnC,OAAO1B,MAAM2B,IAAI,CAAC,SAACC,IAAI;YACrB,OAAOA,KAAKrC,IAAI,KAAKkC,iBAAiBG,KAAKpC,WAAW,KAAKkC;QAC7D;IACF;IAEA,IAAK,IAAIG,IAAI,GAAGA,IAAIhB,GAAGiB,GAAG,CAACC,MAAM,EAAEF,IAAK;QACtC,IAAMG,QAAQnB,GAAGiB,GAAG,CAACD,EAAE;QAEvB,IAAMI,OAAOC,iCAAOC,IAAI,CAACH,MAAMI,IAAI,EAAE,OAAOC,OAAO,GAAGC,QAAQ,CAAC;QAC/D,IAAMV,OAAOJ,QAAQS,MAAMD,MAAMN,KAAK;QACtC,IAAI,CAACE,MACH,MAAMlB,MAAM,mCAAmCsB;QAEjD,IAAM3C,UAAUuC,KAAKvC,OAAO;QAC5B,IAAMgC,UAAUF,oBAAoB9B;QAEpC,IAAMkD,aAAa;YACjBC,mBAAmB;YACnBC,KAAKZ;YACLR,SAAAA;YACAqB,MAAMd;QACR;QACAZ,IAAInB,IAAI,CAAC0C;IACX;IACA,IAAMI,cAAc3B,IAAI4B,KAAK,GAAGC,KAAK;IACrC,OAAOF;AACT;AAAC,IAAAG,iCAAAC,cAAA,CAAA,UAAA,GACc;IACblD,MAAAA;AACF","sources":["index.ts"],"sourcesContent":["const bitcoin = require(\"bitcoinjs-lib\");\nimport { chains, toBitcoinJS } from \"@hyperbitjs/chains\";\n\ninterface IUTXO {\n  address: string;\n  assetName: string;\n  txid: string;\n  outputIndex: number;\n  script: string;\n  satoshis: number;\n  height?: number;\n  value: number;\n}\n\nexport function sign(\n  network: \"aidp\" | \"aidp-test\" | \"evr\" | \"evr-test\",\n  rawTransactionHex: string,\n  UTXOs: Array<IUTXO>,\n  privateKeys: any\n): string {\n  const networkMapper = {\n    aidp: chains.aidp.main,\n    \"aidp-test\": chains.aidp.test,\n    evr: chains.evr.main,\n    \"evr-test\": chains.evr.test,\n  };\n\n  const coin = networkMapper[network];\n\n  if (!coin) {\n    throw new Error(\n      \"Validation error, first argument network must be aidp, aidp-test, evr or evr-test\"\n    );\n  }\n\n  //@ts-ignore\n  const AIDPCOIN = toBitcoinJS(coin);\n\n  const tx = bitcoin.Transaction.fromHex(rawTransactionHex);\n  const txb = bitcoin.TransactionBuilder.fromTransaction(tx, AIDPCOIN);\n\n  function getKeyPairByAddress(address) {\n    const wif = privateKeys[address];\n    const keyPair = bitcoin.ECPair.fromWIF(wif, AIDPCOIN);\n    return keyPair;\n  }\n\n  function getUTXO(transactionId, index) {\n    return UTXOs.find((utxo) => {\n      return utxo.txid === transactionId && utxo.outputIndex === index;\n    });\n  }\n\n  for (let i = 0; i < tx.ins.length; i++) {\n    const input = tx.ins[i];\n\n    const txId = Buffer.from(input.hash, \"hex\").reverse().toString(\"hex\");\n    const utxo = getUTXO(txId, input.index);\n    if (!utxo) {\n      throw Error(\"Could not find UTXO for input \" + input);\n    }\n    const address = utxo.address;\n    const keyPair = getKeyPairByAddress(address);\n\n    const signParams = {\n      prevOutScriptType: \"p2pkh\",\n      vin: i,\n      keyPair,\n      UTXO: utxo,\n    };\n    txb.sign(signParams);\n  }\n  const signedTxHex = txb.build().toHex();\n  return signedTxHex;\n}\nexport default {\n  sign,\n};\n"],"names":["_chains","require","bitcoin","IUTXO","address","assetName","txid","outputIndex","script","satoshis","height","value","sign","network","rawTransactionHex","UTXOs","Array","privateKeys","networkMapper","aidp","chains","main","test","evr","coin","Error","AIDPCOIN","toBitcoinJS","tx","Transaction","fromHex","txb","TransactionBuilder","fromTransaction","getKeyPairByAddress","wif","keyPair","ECPair","fromWIF","getUTXO","transactionId","index","find","utxo","i","ins","length","input","txId","Buffer","from","hash","reverse","toString","signParams","prevOutScriptType","vin","UTXO","signedTxHex","build","toHex","_default","exports"],"version":3,"file":"index.cjs.map"}